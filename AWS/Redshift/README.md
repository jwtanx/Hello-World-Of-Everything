# Redshift
Dialect: PostgreSQL

## SQL Syntax

### Concat
```sql
-- Works
SELECT CONCAT('Hello', CONCAT('-', 'World')) AS formatted_text;

-- Works
SELECT 'Hello' || '-' || 'World' AS formatted_text;

-- Does not work
SELECT CONCAT('Hello', '-', 'World') AS formatted_text;
```

Python function to create a `CONCAT` statement
```python
def recursive_concat(items: list[str] | None | str) -> str | None:
    """
    Recursively concatenate a list of strings with a delimiter '-'
    Due to Redshift limitation for concat, we cannot do concat('a', 'b', 'c', ...)
    Return None if items is None for normal dq tests in generate_dq_tests_insert_ddl.py

    Args:
        items: list of strings to concatenate

    Returns:
        str: concatenated string with the delimiter '-'
             Example: concat(dashboard, concat('-', concat(pages, concat('-', metrics_name))))
    """
    if items == None or isinstance(items, str):
        return items
    if len(items) == 1:
        return items[0]
    else:
        return f"concat({items[0]}, concat('-', {recursive_concat(items[1:])}))"
```

### Escape single quotes
```python
def escape_quotes(value: str | None) -> str | None:
    """
    Escape single quotes in a string

    Args:
        value: string to escape single quotes

    Returns:
        str: string with single quotes escaped
    """
    return value if value is None else value.replace("'", r"\'")
```
But note that when you are trying to insert value with a quote, it will be escaped with another single quotes.
```sql
INSERT INTO schema.table (column_name) VALUES ('this is a ''quote''');
```

### Replace None with 'NULL' string
```python
def replace_none(value):
    """
    Replace None with 'NULL' string

    Args:
        value: value to replace None

    Returns:
        str: 'NULL' if value is None, else str(value)
    """
    if value == None:
        return 'NULL'
    elif isinstance(value, str):
        return f"'{value}'"
    else:
        return str(value)
```

### Replace `\n` and multiple spaces with a single space
```sql
SELECT REGEXP_REPLACE(text, '\\s+', ' ') AS formatted_text FROM schema.table;
```

### Replace `\n` with a space
```sql
SELECT REPLACE(text, CHR(10), ' ') AS formatted_text FROM schema.table;
```

## DDL
### Create table with identity (Auto-increment)
```sql
-- https://www.postgresqltutorial.com/postgresql-tutorial/postgresql-identity-column/
CREATE TABLE public.jw_test (
    test_id INT GENERATED BY DEFAULT AS IDENTITY(1,1) NOT NULL,
    name VARCHAR(255),
    datetime TIMESTAMPTZ
)

-- IDENTITY(1, 1) == IDENTITY(START WITH 1 INCREMENT BY 1)

INSERT INTO public.jw_test
VALUES(DEFAULT, 'JOHN', '2024-08-08T12:34Z');

select * from public.jw_test;
```
With `GENERATED BY DEFAULT AS IDENTITY(1,1) NOT NULL`, we can insert a row without the specifying all the columns like the one below
```
INSERT INTO public.jw_test (name, datetime)
VALUES('JOHN', '2024-08-08T12:34Z');
```
This can simplify the columns name to be inserted when there is a lot columns in the table.


### Overriding the default value of a column (Not applicable in Redshift)
```sql
INSERT INTO public.jw_test (test_id, name, datetime)
OVERRIDING SYSTEM VALUE
VALUES(2, 'Gary', '2024-08-08T12:34Z');
```

## DISTSTYLE
### Type: ALL
This is suitable for small tables that are joined with large tables. The small table is replicated to all nodes in the cluster. This is the default distribution style for small tables.
```sql
CREATE TABLE public.diststyle_test DISTSTYLE ALL AS (
    SELECT * FROM public.jw_test WHERE name = 'JOHN'
)
SELECT * FROM public.diststyle_test;
```

### Type: EVEN
This is suitable for large tables that are joined with large tables. The rows are distributed across the slices in a round-robin fashion.
```sql
CREATE TABLE public.diststyle_test DISTSTYLE EVEN AS (
    SELECT * FROM public.jw_test
)
SELECT * FROM public.diststyle_test;
```

### Type: KEY
This is suitable for large tables that are joined with large tables. The rows are distributed according to the values in one column. The rows with the same value are distributed to the same slice.
```sql
CREATE TABLE public.diststyle_test DISTSTYLE KEY (name) AS (
    SELECT * FROM public.jw_test
)
SELECT * FROM public.diststyle_test;
```

## SORTKEY
### Compound sort key
The table will be sorted for faster query performance. The first column is the primary sort key, the second column is the secondary sort key, and so on.
```sql
CREATE TABLE public.sortkey_test SORTKEY (name, datetime) AS (
    SELECT * FROM public.jw_test
)
SELECT * FROM public.sortkey_test;
```
