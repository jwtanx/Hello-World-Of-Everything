# Redshift
Dialect: PostgreSQL

## SQL Syntax

### Concat
```sql
-- Works
SELECT CONCAT('Hello', CONCAT('-', 'World')) AS formatted_text;

-- Works
SELECT 'Hello' || '-' || 'World' AS formatted_text;

-- Does not work
SELECT CONCAT('Hello', '-', 'World') AS formatted_text;
```

Python function to create a `CONCAT` statement
```python
def recursive_concat(items: list[str] | None | str) -> str | None:
    """
    Recursively concatenate a list of strings with a delimiter '-'
    Due to Redshift limitation for concat, we cannot do concat('a', 'b', 'c', ...)
    Return None if items is None for normal dq tests in generate_dq_tests_insert_ddl.py

    Args:
        items: list of strings to concatenate

    Returns:
        str: concatenated string with the delimiter '-'
             Example: concat(dashboard, concat('-', concat(pages, concat('-', metrics_name))))
    """
    if items == None or isinstance(items, str):
        return items
    if len(items) == 1:
        return items[0]
    else:
        return f"concat({items[0]}, concat('-', {recursive_concat(items[1:])}))"
```

### Escape single quotes
```python
def escape_quotes(value: str | None) -> str | None:
    """
    Escape single quotes in a string

    Args:
        value: string to escape single quotes

    Returns:
        str: string with single quotes escaped
    """
    return value if value is None else value.replace("'", r"\'")
```
But note that when you are trying to insert value with a quote, it will be escaped with another single quotes.
```sql
INSERT INTO schema.table (column_name) VALUES ('this is a ''quote''');
```

### Replace None with 'NULL' string
```python
def replace_none(value):
    """
    Replace None with 'NULL' string

    Args:
        value: value to replace None

    Returns:
        str: 'NULL' if value is None, else str(value)
    """
    if value == None:
        return 'NULL'
    elif isinstance(value, str):
        return f"'{value}'"
    else:
        return str(value)
```

### Replace `\n` and multiple spaces with a single space
```sql
SELECT REGEXP_REPLACE(text, '\\s+', ' ') AS formatted_text FROM schema.table;
```

### Replace `\n` with a space
```sql
SELECT REPLACE(text, CHR(10), ' ') AS formatted_text FROM schema.table;
```

## DDL
### Create table with identity (Auto-increment)
```sql
-- https://www.postgresqltutorial.com/postgresql-tutorial/postgresql-identity-column/
CREATE TABLE public.jw_test (
    test_id INT GENERATED BY DEFAULT AS IDENTITY(1,1) NOT NULL,
    name VARCHAR(255),
    datetime TIMESTAMPTZ
)

-- IDENTITY(1, 1) == IDENTITY(START WITH 1 INCREMENT BY 1)

INSERT INTO public.jw_test
VALUES(DEFAULT, 'JOHN', '2024-08-08T12:34Z');

select * from public.jw_test;
```
With `GENERATED BY DEFAULT AS IDENTITY(1,1) NOT NULL`, we can insert a row without the specifying all the columns like the one below
```
INSERT INTO public.jw_test (name, datetime)
VALUES('JOHN', '2024-08-08T12:34Z');
```
This can simplify the columns name to be inserted when there is a lot columns in the table.


### Overriding the default value of a column (Not applicable in Redshift)
```sql
INSERT INTO public.jw_test (test_id, name, datetime)
OVERRIDING SYSTEM VALUE
VALUES(2, 'Gary', '2024-08-08T12:34Z');
```

## DISTSTYLE
### Type: ALL
This is suitable for small tables that are joined with large tables. The small table is replicated to all nodes in the cluster. This is the default distribution style for small tables.
```sql
CREATE TABLE public.diststyle_test DISTSTYLE ALL AS (
    SELECT * FROM public.jw_test WHERE name = 'JOHN'
)
SELECT * FROM public.diststyle_test;
```

### Type: EVEN
This is suitable for large tables that are joined with large tables. The rows are distributed across the slices in a round-robin fashion.
```sql
CREATE TABLE public.diststyle_test DISTSTYLE EVEN AS (
    SELECT * FROM public.jw_test
)
SELECT * FROM public.diststyle_test;
```

### Type: KEY
This is suitable for large tables that are joined with large tables. The rows are distributed according to the values in one column. The rows with the same value are distributed to the same slice.
```sql
CREATE TABLE public.diststyle_test DISTSTYLE KEY (name) AS (
    SELECT * FROM public.jw_test
)
SELECT * FROM public.diststyle_test;
```

## SORTKEY
### Compound sort key
The table will be sorted for faster query performance. The first column is the primary sort key, the second column is the secondary sort key, and so on.
```sql
CREATE TABLE public.sortkey_test SORTKEY (name, datetime) AS (
    SELECT * FROM public.jw_test
)
SELECT * FROM public.sortkey_test;
```

https://docs.aws.amazon.com/redshift/latest/dg/JSON_EXTRACT_PATH_TEXT.html

Replace Azure Synapse from JSON_VALUE
JSON_VALUE(other_relevant_columns, '$.country') AS country,
to
JSON_EXTRACT_PATH_TEXT(other_relevant_columns, 'country') AS country,

## GRANT
### Checking if there is usage of a table on a role
```sql
SELECT has_schema_privilege('user_a', 'schema_name', 'USAGE');
SELECT has_table_privilege('user_a', 'schema_name.table_name', 'SELECT');
```

### Granting normal DML
```sql
GRANT INSERT, UPDATE, DELETE, DROP ON ALL TABLES IN SCHEMA
    schema_a, schema_b
TO ROLE role_a -- or TO "user_a"


GRANT CREATE ON SCHEMA
    schema_a, schema_b
TO ROLE role_a -- or TO "user_a"
```

### Revoking normal DML
```sql
REVOKE INSERT, UPDATE, DELETE, DROP ON ALL TABLES IN SCHEMA
    schema_a, schema_b
FROM ROLE role_a
```

### USAGE must be granted on schema level to access the tables
```sql
GRANT USAGE ON SCHEMA
    schema_a, schema_b
TO ROLE role_a
```

### Revoking USAGE
```sql
REVOKE USAGE ON SCHEMA
    schema_a, schema_b
FROM ROLE role_a
```

### Granting assumed role
```sql
GRANT ASSUMEROLE
    ON default
    TO "user_a"
    FOR COPY, UNLOAD;
```

### Granting a role to another role
```sql
GRANT ROLE "read_all_access_role" TO "user_a"
GRANT ROLE "read_all_access_role" TO role_a
```

### Get owner of the table
```
SELECT tablename, tableowner FROM pg_tables
```

## Checking all perms
```sql

-- Check if the user has the usage / create / alter perm on the schema
SELECT HAS_SCHEMA_PRIVILEGE('user_a', 'schema', 'USAGE')
SELECT HAS_SCHEMA_PRIVILEGE('user_a', 'schema', 'CREATE')
SELECT HAS_SCHEMA_PRIVILEGE('user_a', 'schema', 'ALTER')

-- Check if the user has the select / insert / update / delete / drop perm on the table
SELECT HAS_TABLE_PRIVILEGE('user_a', 'schema.table', 'SELECT')
SELECT HAS_TABLE_PRIVILEGE('user_a', 'schema.table', 'INSERT')
SELECT HAS_TABLE_PRIVILEGE('user_a', 'schema.table', 'UPDATE')
SELECT HAS_TABLE_PRIVILEGE('user_a', 'schema.table', 'DELETE')
SELECT HAS_TABLE_PRIVILEGE('user_a', 'schema.table', 'DROP')

-- Check user access control for each schema
SELECT TOP 10 * FROM pg_namespace WHERE nspname LIKE '%schema%'

-- Check who is the owner of the table
SELECT TOP 10 * FROM pg_tables WHERE schemaname LIKE '%schema%'

-- Check schema privileges
SELECT TOP 10 * FROM svv_schema_privileges WHERE namespace_name LIKE '%schema%';

-- Check table privileges
SELECT TOP 10 * FROM svv_relation_privileges WHERE namespace_name LIKE '%schema%'

-- Check if a role is a member of another role
role_is_member_of('role_name_to_check',  'granted_role_name')

-- Check if a user is a member of a role
user_is_member_of('user_name',  'granted_role_name')
```