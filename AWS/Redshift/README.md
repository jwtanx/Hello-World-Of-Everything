# Redshift
Dialect: PostgreSQL

## SQL Syntax

### Concat
```sql
-- Works
SELECT CONCAT('Hello', CONCAT('-', 'World')) AS formatted_text;

-- Works
SELECT 'Hello' || '-' || 'World' AS formatted_text;

-- Does not work
SELECT CONCAT('Hello', '-', 'World') AS formatted_text;
```

Python function to create a `CONCAT` statement
```python
def recursive_concat(items: list[str] | None | str) -> str | None:
    """
    Recursively concatenate a list of strings with a delimiter '-'
    Due to Redshift limitation for concat, we cannot do concat('a', 'b', 'c', ...)
    Return None if items is None for normal dq tests in generate_dq_tests_insert_ddl.py

    Args:
        items: list of strings to concatenate

    Returns:
        str: concatenated string with the delimiter '-'
             Example: concat(dashboard, concat('-', concat(pages, concat('-', metrics_name))))
    """
    if items == None or isinstance(items, str):
        return items
    if len(items) == 1:
        return items[0]
    else:
        return f"concat({items[0]}, concat('-', {recursive_concat(items[1:])}))"
```

### Escape single quotes
```python
def escape_quotes(value: str | None) -> str | None:
    """
    Escape single quotes in a string

    Args:
        value: string to escape single quotes

    Returns:
        str: string with single quotes escaped
    """
    return value if value is None else value.replace("'", r"\'")
```
But note that when you are trying to insert value with a quote, it will be escaped with another single quotes.
```sql
INSERT INTO schema.table (column_name) VALUES ('this is a ''quote''');
```

### Replace None with 'NULL' string
```python
def replace_none(value):
    """
    Replace None with 'NULL' string

    Args:
        value: value to replace None

    Returns:
        str: 'NULL' if value is None, else str(value)
    """
    if value == None:
        return 'NULL'
    elif isinstance(value, str):
        return f"'{value}'"
    else:
        return str(value)
```

### Replace `\n` and multiple spaces with a single space
```sql
SELECT REGEXP_REPLACE(text, '\\s+', ' ') AS formatted_text FROM schema.table;
```

### Replace `\n` with a space
```sql
SELECT REPLACE(text, CHR(10), ' ') AS formatted_text FROM schema.table;
```

## DDL
### Create table with identity (Auto-increment)
```sql
-- https://www.postgresqltutorial.com/postgresql-tutorial/postgresql-identity-column/
CREATE TABLE public.jw_test (
    test_id INT GENERATED BY DEFAULT AS IDENTITY(1,1) NOT NULL,
    name VARCHAR(255),
    datetime TIMESTAMPTZ
)

-- IDENTITY(1, 1) == IDENTITY(START WITH 1 INCREMENT BY 1)

INSERT INTO public.jw_test
VALUES(DEFAULT, 'JOHN', '2024-08-08T12:34Z');

select * from public.jw_test;
```
With `GENERATED BY DEFAULT AS IDENTITY(1,1) NOT NULL`, we can insert a row without the specifying all the columns like the one below
```
INSERT INTO public.jw_test (name, datetime)
VALUES('JOHN', '2024-08-08T12:34Z');
```
This can simplify the columns name to be inserted when there is a lot columns in the table.


### Overriding the default value of a column (Not applicable in Redshift)
```sql
INSERT INTO public.jw_test (test_id, name, datetime)
OVERRIDING SYSTEM VALUE
VALUES(2, 'Gary', '2024-08-08T12:34Z');
```

## DISTSTYLE
### Type: ALL
This is suitable for small tables that are joined with large tables. The small table is replicated to all nodes in the cluster. This is the default distribution style for small tables.
```sql
CREATE TABLE public.diststyle_test DISTSTYLE ALL AS (
    SELECT * FROM public.jw_test WHERE name = 'JOHN'
)
SELECT * FROM public.diststyle_test;
```

### Type: EVEN
This is suitable for large tables that are joined with large tables. The rows are distributed across the slices in a round-robin fashion.
```sql
CREATE TABLE public.diststyle_test DISTSTYLE EVEN AS (
    SELECT * FROM public.jw_test
)
SELECT * FROM public.diststyle_test;
```

### Type: KEY
This is suitable for large tables that are joined with large tables. The rows are distributed according to the values in one column. The rows with the same value are distributed to the same slice.
```sql
CREATE TABLE public.diststyle_test DISTSTYLE KEY (name) AS (
    SELECT * FROM public.jw_test
)
SELECT * FROM public.diststyle_test;
```

## SORTKEY
### Compound sort key
The table will be sorted for faster query performance. The first column is the primary sort key, the second column is the secondary sort key, and so on.
```sql
CREATE TABLE public.sortkey_test SORTKEY (name, datetime) AS (
    SELECT * FROM public.jw_test
)
SELECT * FROM public.sortkey_test;
```

https://docs.aws.amazon.com/redshift/latest/dg/JSON_EXTRACT_PATH_TEXT.html

Replace Azure Synapse from JSON_VALUE
JSON_VALUE(other_relevant_columns, '$.country') AS country,
to
JSON_EXTRACT_PATH_TEXT(other_relevant_columns, 'country') AS country,

## GRANT
### Checking if there is usage of a table on a role
```sql
SELECT has_schema_privilege('user_a', 'schema_name', 'USAGE');
SELECT has_table_privilege('user_a', 'schema_name.table_name', 'SELECT');
```

### Granting normal DML
```sql
GRANT INSERT, UPDATE, DELETE, DROP ON ALL TABLES IN SCHEMA
    schema_a, schema_b
TO ROLE role_a -- or TO "user_a"


GRANT CREATE ON SCHEMA
    schema_a, schema_b
TO ROLE role_a -- or TO "user_a"
```

### Revoking normal DML
```sql
REVOKE INSERT, UPDATE, DELETE, DROP ON ALL TABLES IN SCHEMA
    schema_a, schema_b
FROM ROLE role_a
```

### USAGE must be granted on schema level to access the tables
```sql
GRANT USAGE ON SCHEMA
    schema_a, schema_b
TO ROLE role_a
```

### Revoking USAGE
```sql
REVOKE USAGE ON SCHEMA
    schema_a, schema_b
FROM ROLE role_a
```

### Granting assumed role
```sql
GRANT ASSUMEROLE
    ON default
    TO "user_a"
    FOR COPY, UNLOAD;
```

### Granting a role to another role
```sql
GRANT ROLE "read_all_access_role" TO "user_a"
GRANT ROLE "read_all_access_role" TO role_a
```

### Get owner of the table
```
SELECT tablename, tableowner FROM pg_tables
```

## Checking all perms
```sql

-- Check if the user has the usage / create / alter perm on the schema
SELECT HAS_SCHEMA_PRIVILEGE('user_a', 'schema', 'USAGE')
SELECT HAS_SCHEMA_PRIVILEGE('user_a', 'schema', 'CREATE')
SELECT HAS_SCHEMA_PRIVILEGE('user_a', 'schema', 'ALTER')

-- Check if the user has the select / insert / update / delete / drop perm on the table
SELECT HAS_TABLE_PRIVILEGE('user_a', 'schema.table', 'SELECT')
SELECT HAS_TABLE_PRIVILEGE('user_a', 'schema.table', 'INSERT')
SELECT HAS_TABLE_PRIVILEGE('user_a', 'schema.table', 'UPDATE')
SELECT HAS_TABLE_PRIVILEGE('user_a', 'schema.table', 'DELETE')
SELECT HAS_TABLE_PRIVILEGE('user_a', 'schema.table', 'DROP')

-- Check if the user has the select / insert / update / delete / drop perm on all tables in the schema
SELECT usename,
HAS_TABLE_PRIVILEGE(usename, 'schema.table', 'SELECT') AS can_select,
HAS_TABLE_PRIVILEGE(usename, 'schema.table', 'INSERT') AS can_insert,
HAS_TABLE_PRIVILEGE(usename, 'schema.table', 'UPDATE') AS can_update,
HAS_TABLE_PRIVILEGE(usename, 'schema.table', 'DELETE') AS can_delete,
HAS_TABLE_PRIVILEGE(usename, 'schema.table', 'DROP') AS can_drop
FROM pg_user
ORDER BY usename;

-- Check user access control for each schema
SELECT TOP 10 * FROM pg_namespace WHERE nspname LIKE '%schema%'

-- Check who is the owner of the table
SELECT TOP 10 * FROM pg_tables WHERE schemaname LIKE '%schema%'

-- Check schema privileges
SELECT TOP 10 * FROM svv_schema_privileges WHERE namespace_name LIKE '%schema%';

-- Check table privileges
SELECT TOP 10 * FROM svv_relation_privileges WHERE namespace_name LIKE '%schema%'

-- Check if a role is a member of another role
role_is_member_of('role_name_to_check',  'granted_role_name')

-- Check if a user is a member of a role
user_is_member_of('user_name',  'granted_role_name')
```

## Validating the datatypes between view and its materialized table
```sql
-- Validating the data types and order of columns between a table and a view
SELECT
    T.TABLE_NAME AS table_name,
    V.TABLE_NAME AS view_name,
    T.COLUMN_NAME AS column_name,
    T.DATA_TYPE AS table_data_type,
    V.DATA_TYPE AS view_data_type,
    T.ORDINAL_POSITION AS table_ordinal_position,
    V.ORDINAL_POSITION AS view_ordinal_position
FROM INFORMATION_SCHEMA.COLUMNS AS T
JOIN INFORMATION_SCHEMA.COLUMNS AS V
    ON T.COLUMN_NAME = V.COLUMN_NAME
WHERE T.TABLE_SCHEMA = 'SCHEMA_NAME'
    AND V.TABLE_SCHEMA = 'SCHEMA_NAME'
    AND T.TABLE_NAME = 'TABLE_NAME'
    AND V.TABLE_NAME = 'VIEW_NAME'
    AND (
        T.ORDINAL_POSITION != V.ORDINAL_POSITION
        OR T.DATA_TYPE != V.DATA_TYPE
    )
ORDER BY
    T.ORDINAL_POSITION;
```

## Stored Procedure
### Alter schema owner
If you do not have superuser permission, you cannot change the owner, even if youa re the owner of the schema.
```sql
CREATE SCHEMA schema_name;
ALTER SCHEMA schema_name OWNER TO new_owner;
-- Permission denied: You must be a superuser to alter the owner of schema
```

To solve this, we can create a stored procedure and create it using a superuser
```sql
CREATE OR REPLACE PROCEDURE admin.sp_alter_schema_owner(
    schema_name TEXT
)
LANGUAGE plpgsql
AS $$
DECLARE
    r RECORDS;
    -- Can add more variables here, eg: new_owner VARCHAR(255);
BEGIN
    IF SPLIT(schema_name, '_')[0] IN ('public', 'private') THEN
        RAISE EXCEPTION 'Schema name must be in the format schema_name';
    ELSE
        FOR r IN (SELECT tablename FROM pg_tables WHERE schemaname = schema_name) LOOP
            RAISE NOTICE 'ALTER TABLE %.% OWNER TO "new_owner"', schema_name, r.tablename;
            EXECUTE 'ALTER TABLE ' || schema_name || '.' || r.tablename || ' OWNER TO "new_owner"';
        END LOOP;
        FOR r IN (SELECT viewname FROM pg_views WHERE schemaname = schema_name) LOOP
            RAISE NOTICE 'ALTER VIEW %.% OWNER TO "new_owner"', schema_name, r.viewname;
            EXECUTE 'ALTER VIEW ' || schema_name || '.' || r.viewname || ' OWNER TO "new_owner"';
        END LOOP;
        RAISE NOTICE 'ALTER SCHEMA % OWNER TO "new_owner"', schema_name;
        EXECUTE 'ALTER SCHEMA ' || schema_name || ' OWNER TO "new_owner"';
    END IF;
END;
$$ SECURITY DEFINER;

GRANT EXECUTE ON PROCEDURE admin.sp_alter_schema_owner TO ROLE role_name;
```

NOTE:
- SECURITY DEFINER allows the procedure to be executed with the privileges of the user who created it (superuser), rather than the user who calls it.
- SECURITY INVOKER is the default behavior, where the procedure runs with the privileges of the user who calls it.
- I have tried on setting the EXECUTE 'CALL admin.f_get_scheame_owner('schema_name')' inside the procedure, but it gives error "cannot call a procedure from within a procedure". EXECUTE command can only run SQL statements, not PL/pgSQL calls.

### Get the list of owner of the stored procedures
```sql
SELECT p.proname sp_name, n.nspname sp_schema, p.proargnames sp_args, p.proowner owner_id, u.usename owner_name
FROM pg_catalog.pg_namespace n
JOIN pg_catalog.pg_proc p ON n.oid = p.pronamespace
JOIN pg_user pu on p.proowner = pu.usesysid
WHERE p.proowner > 1;
```